#!/usr/bin/env python3
import re

# Token specifications
TOKEN_SPECIFICATIONS = [
    ("Int Keyword", r"int\b"),           # Keyword: int
    ("Void Keyword", r"void\b"),         # Keyword: void
    ("Return Keyword", r"return\b"),     # Keyword: return
    ("Identifier", r"[a-zA-Z_]\w*\b"),  # Valid identifiers
    ("Constant", r"[0-9]+\b"),           # Integer constant
    ("Open parenthesis", r"\("),         # Open parenthesis
    ("Close parenthesis", r"\)"),        # Close parenthesis
    ("Open brace", r"\{"),               # Open brace
    ("Close brace", r"\}"),              # Close brace
    ("Semicolon", r";"),                 # Semicolon
]

def tokenize(code):
    tokens = []
    position = 0  # Position in the input code

    while position < len(code):
        # Trim whitespace from the start
        if code[position].isspace():
            position += 1  # Skip whitespace
            continue
        
        matched = False
        
        # Test each token specification against the input
        for token_name, token_regex in TOKEN_SPECIFICATIONS:
            regex = re.compile(token_regex)
            
            # Match at the current position
            match = regex.match(code, position)
            if match:
                value = match.group()
                tokens.append((token_name, value))
                position = match.end()  # Move the position after the match
                matched = True
                break
        
        if not matched:
            # If no tokens matched, raise an error
            raise RuntimeError(f'Unexpected character "{code[position]}" at position {position}')

    return tokens

class Node:
    pass

class Constant(Node):
    def __init__(self, value):
        self.value = value
        
class Identifier(Node):
    def __init__(self, name):
        self.value = name
        
class Function(Node):
    def __init__(self, name, body):
        self.name = name 
        self.body = body
        
class Return(Node):
    def __init__(self, expression):
        self.expression = expression

class Program(Node):
    def __init__(self, function):
        self.function = function
    
class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.current_token_index = 0
    
    def current_token(self):
        if self.current_token_index < len(self.tokens):
            return self.tokens[self.current_token_index]
        return None
    
    def take_token(self):
        if self.current_token_index < len(self.tokens):
            token = self.tokens[self.current_token_index]
            self.current_token_index += 1
            return token
        return None
    
    def expect(self, expected):
        actual = self.take_token()
        if actual is None or actual[0] != expected:
            raise RuntimeError(f'Expected token {expected} but got {actual}')
        return actual  # Return the actual token for further use
        
    def parse(self):
        function = self.parse_function()
        return Program(function)
    
    def parse_function(self):
        self.expect('Int Keyword')  # Expect the "int" keyword
        identifier_token = self.expect("Identifier")  # Expect an identifier for the function name
        function_name = Identifier(identifier_token[1])  # Safe access here
        
        self.expect('Open parenthesis')  # Expect the open parenthesis
        self.expect('Void Keyword')       # Expect the "void" keyword
        self.expect('Close parenthesis')  # Expect the close parenthesis
        self.expect("Open brace")         # Expect the open brace
        
        return_statement = self.parse_statement()  # Parse the function body
        self.expect("Close brace")  # Expect the close brace
        
        return Function(function_name, return_statement)
    
    # def parse_statement(self):
        # if self.current_token()[0] == "Return Keyword":
        #     self.expect("Return Keyword")
        #     expression = self.parse_expression()
        #     self.expect("Semicolon")  # Explicitly check for semicolon
        #     return Return(expression)

    # def parse_expression(self):
    #     token = self.current_token()
    #     if token[0] == "Constant":
    #         self.take_token()
    #         return Constant(int(token[1]))
    #     else:
    #         raise RuntimeError("Unexpected expression")
    
    def parse_statement(self):
        self.expect("Return Keyword")  # Expect the "return" keyword
        return_val= self.parse_expression()  # Parse the expression (should be Constant)
        # print(return_val.value[1])
        self.expect("Semicolon")  # Expect the semicolon after the return value
        return Return(return_val)
        
    def parse_expression(self):
        token = self.current_token()
        if token is None:
            raise RuntimeError('Unexpected end of input in expression')
        
        if token[0] == "Constant":  # Check for constant token
            self.take_token()
            return Constant(token)  
        
        raise RuntimeError(f'Unexpected token in expression: {token}')

# Example code to tokenize and parse
if __name__ == "__main__":
    code = """
    int main(void) {
        return 5;
    }
    """

    try:
        # Tokenize the code
        tokens = tokenize(code)
        print(tokens)
        print("Tokens:")
        for token in tokens:
            print(token)

        # Parse the tokens
        parser = Parser(tokens)
        program = parser.parse()
        print("\nParsed program:")
        print(f"Function Name: {program.function.name.value}")
        print(f"Return Value: {program.function.body.expression.value}")

    except RuntimeError as e:
        print(f"Error: {e}")
