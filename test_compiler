#!/usr/bin/env python3
import re

# Token specifications
TOKEN_SPECIFICATIONS = [
    ("Int Keyword", r"int\b"),           # Keyword: int
    ("Void Keyword", r"void\b"),         # Keyword: void
    ("Return Keyword", r"return\b"),     # Keyword: return
    ("Identifier", r"[a-zA-Z_]\w*"),     # Valid identifiers
    ("Constant", r"[0-9]+"),             # Integer constant
    ("Open parenthesis", r"\("),         # Open parenthesis
    ("Close parenthesis", r"\)"),        # Close parenthesis
    ("Open brace", r"\{"),               # Open brace
    ("Close brace", r"\}"),              # Close brace
    ("Semicolon", r";"),                 # Semicolon
]

def tokenize(code):
    tokens = []
    position = 0  # Position in the input code

    while position < len(code):
        # Trim whitespace from the start
        if code[position].isspace():
            position += 1  # Skip whitespace
            continue
        
        matched = False
        
        # Test each token specification against the input
        for token_name, token_regex in TOKEN_SPECIFICATIONS:
            regex = re.compile(token_regex)
            
            # Match at the current position
            match = regex.match(code, position)
            if match:
                value = match.group()
                tokens.append((token_name, value))
                position = match.end()  # Move the position after the match
                matched = True
                break
        
        if not matched:
            # If no tokens matched, raise an error
            raise RuntimeError(f'Unexpected character "{code[position]}" at position {position}')

    return tokens

class Node:
    pass

class Constant(Node):
    def __init__(self, value):
        self.value = value
        
class Identifier(Node):
    def __init__(self, name):
        self.value = name
        
class Function(Node):
    def __init__(self, name, body):
        self.name = name 
        self.body = body
        
class Return(Node):
    def __init__(self, expression):
        self.expression = expression

class Program(Node):
    def __init__(self, function):
        self.function = function
    
class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.current_token_index = 0
    
    def current_token(self):
        if self.current_token_index < len(self.tokens):
            return self.tokens[self.current_token_index]
        return None
    
    def take_token(self):
        if self.current_token_index < len(self.tokens):
            token = self.tokens[self.current_token_index]
            self.current_token_index += 1
            return token
        return None
    
    def expect(self, expected):
        actual = self.take_token()
        if actual is None or actual[0] != expected:
            raise RuntimeError(f'Expected token {expected} but got {actual}')
        return actual  # Return the actual token for further use
        
    def parse(self):
        function = self.parse_function()
        return Program(function)
    
    def parse_function(self):
        self.expect('Int Keyword')  # Expect the "int" keyword
        identifier_token = self.expect("Identifier")  # Expect an identifier for the function name
        function_name = Identifier(identifier_token[1])  # Safe access here
        
        self.expect('Open parenthesis')  # Expect the open parenthesis
        self.expect('Void Keyword')       # Expect the "void" keyword
        self.expect('Close parenthesis')  # Expect the close parenthesis
        self.expect("Open brace")         # Expect the open brace
        
        return_statement = self.parse_statement()  # Parse the function body
        self.expect("Close brace")  # Expect the close brace
        
        return Function(function_name, return_statement)
    
    def parse_statement(self):
        self.expect("Return Keyword")  # Expect the "return" keyword
        return_val = self.parse_expression()  # Parse the expression (should be Constant)
        self.expect("Semicolon")  # Expect the semicolon after the return value
        return Return(return_val)
        
    def parse_expression(self):
        token = self.current_token()
        if token is None:
            raise RuntimeError('Unexpected end of input in expression')
        
        if token[0] == "Constant":  # Check for constant token
            self.take_token()
            return Constant(int(token[1]))  # Convert string to integer
        
        raise RuntimeError(f'Unexpected token in expression: {token}')

# Instruction classes for assembly generation
class Instruction(Node):
    """Base class for all instructions."""
    pass

class Mov(Instruction):
    """Represents a 'mov' instruction in assembly."""
    def __init__(self, src, dst):
        self.src = src  # Source operand
        self.dst = dst  # Destination operand

class Ret(Instruction):
    """Represents a 'ret' instruction in assembly."""
    pass  # No operands needed for return instruction

class Imm:
    """Represents an immediate (constant) operand."""
    def __init__(self, value):
        self.value = value  # Integer constant

class Register:
    """Represents a register operand."""
    def __init__(self, name):
        self.name = name  # Name of the register (e.g., "EAX")

class AssemblyGenerator:
    def __init__(self):
        self.assembly_program = []

    def generate(self, ast):
        """Main entry point for generating assembly from the AST."""
        if isinstance(ast, Program):
            self.assembly_program = self.visit_program(ast)
        else:
            raise ValueError("Unknown AST node type")

    def visit_program(self, program):
        """Visit a program node."""
        function_definition = self.visit_function(program.function)
        return function_definition

    def visit_function(self, function):
        """Visit a function definition node."""
        name = function.name  # Assuming name is an Identifier instance
        instructions = self.visit_instructions(function.body)
        return {'name': name.value, 'instructions': instructions}

    def visit_instructions(self, instructions):
        """Visit a list of instructions."""
        assembly_instructions = []
        if isinstance(instructions, Return):
            assembly_instructions.extend(self.visit_return(instructions))
        return assembly_instructions

    def visit_return(self, return_node):
        """Visit a return statement."""
        instructions = []
        # Generate MOV instruction to move return value into EAX
        instructions.append(Mov(self.visit_expression(return_node.expression), Register("EAX")))
        instructions.append(Ret())
        return instructions

    def visit_expression(self, expr):
        """Visit an expression node."""
        if isinstance(expr, Constant):
            return Imm(expr.value)  # Create an immediate operand
        else:
            raise ValueError("Unknown expression type")

    def get_assembly(self):
        """Return the generated assembly program."""
        return self.assembly_program

# Example code to tokenize and parse
if __name__ == "__main__":
    code = """
    int main(void) {
        return 5;
    }
    """

    try:
        # Tokenize the code
        tokens = tokenize(code)
        print("Tokens:")
        for token in tokens:
            print(token)

        parser = Parser(tokens)
        program = parser.parse()

        print("\nParsed program:")
        print(f"Function Name: {program.function.name.value}")
        print(f"Return Value: {program.function.body.expression.value}")

        generator = AssemblyGenerator()
        generator.generate(program)
        assembly = generator.get_assembly()
        print("\nGenerated Assembly:")
        for instr in assembly:
            if isinstance(instr, Mov):
                print(f"mov {instr.src.value}, {instr.dst.name}")
            elif isinstance(instr, Ret):
                print("ret")

    except RuntimeError as e:
        print(f"Error: {e}")
